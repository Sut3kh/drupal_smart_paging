<?php
// $Id$

/**
 * @file
 * Provides smart paging capability to Drupal contents.
 *
 * @author Roland Michael dela Peña.
 * @version $Id$
 */

define('SMART_PAGING_NO_METHOD', -1);
define('SMART_PAGING_PLACEHOLDER_METHOD', 0);
define('SMART_PAGING_CHARACTER_LIMIT_METHOD', 1);
define('SMART_PAGING_WORD_LIMIT_METHOD', 2);

/******************************************************************************
 * Drupal Hooks                                                               *
 ******************************************************************************/
/**
 * Implements hook_menu().
 *
 * Called when Drupal is building menus.  Cache parameter lets module know
 * if Drupal intends to cache menu or not - different results may be
 * returned for either case.
 *
 * @return
 *   An array with the menu path, callback, and parameters.
 */ 
function smart_paging_menu() {
  $items = array();
  $items['admin/config/content/smart_paging'] = array(
    'title'            => 'Administer Smart Paging',
    'description'      => 'Configure Smart Paging default settings',
    'access arguments' => array('administer smart_paging'),
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('smart_paging_admin_settings'),
    'file' 						 => 'includes/smart_paging.admin.inc',
    'weight'					 => 2,
  );
  return $items;
}

/**
 * Implements hook_form_alter()
 */
function smart_paging_form_alter(&$form, &$form_state, $form_id) {
  if (isset($form_state['field']) && isset($form['#entity_type']) && (strpos($form_id, '_node_form') !== FALSE || $form_id == 'user_profile_form' || $form_id == 'taxonomy_form_term')) {
    foreach ($form_state['field'] as $field_name => $field) {
      if ($field[$form[$field_name]['#language']]['instance']['settings']['text_processing']) {
        $text_processing = TRUE;
        break;
      }
    }
    if (isset($text_processing)) {
      foreach (entity_get_info() as $type => $info) {
        $entity_types[$type] = $info['entity keys']['id'];
      }
      $entity_type = $form['#entity_type'];
      if (isset($form_state['term']->{$entity_types[$entity_type]})) {
        $entity_id = $form_state['term']->{$entity_types[$entity_type]};
      }
      elseif (isset($form_state["$entity_type"]->{$entity_types[$entity_type]})) {
        $entity_id = $form_state["$entity_type"]->{$entity_types[$entity_type]};
      }
      if (isset($entity_id)) {
        // Retrieve the stored Smart Paging settings
        $query = db_select('smart_paging', 'sp')
          ->condition('sp.entity_id', $entity_id)
          ->condition('sp.entity_type', $entity_type)
          ->fields('sp', array('configuration'))
          ->execute();
        $smart_paging_config = unserialize($query->fetchField(0));
        $form_state['storage']['smart_paging_entity_id']   = $entity_id;
        $form_state['storage']['smart_paging_entity_type'] = $entity_type;
      }
      $form['smart_paging_settings'] = array(              
        '#type'        => 'fieldset',
        '#title'       => t('Smart Paging settings'),
        '#description' => t('Remember to enable the Smart Paging input filter at !formats to be able to use this feature at your selected text format of filtered text field(s).', array('!formats' => l(t('Text formats settings page'), 'admin/config/content/formats'))),
        '#collapsible' => TRUE,
        '#collapsed'   => TRUE,
        '#weight'      => 20,
      );
      $method_options = _smart_paging_method_list();
      // Only node entity do have Additional settings aesthetics
      if (isset($form_state['node'])) {
        if (variable_get('smart_paging_method', SMART_PAGING_PLACEHOLDER_METHOD) == SMART_PAGING_PLACEHOLDER_METHOD) {
          $value = t(' (placeholder="!value")', array('!value' => variable_get('smart_paging_pagebreak', '<!--pagebreak-->')));
          $default_method = $method_options[SMART_PAGING_PLACEHOLDER_METHOD] . $value;
        }
        elseif (variable_get('smart_paging_method', SMART_PAGING_PLACEHOLDER_METHOD) == SMART_PAGING_CHARACTER_LIMIT_METHOD) {
          $value = t(' (!value characters)', array('!value' => variable_get('smart_paging_character_count', 3072)));
          $default_method = $method_options[SMART_PAGING_CHARACTER_LIMIT_METHOD] . $value;
        }
        elseif (variable_get('smart_paging_method', SMART_PAGING_PLACEHOLDER_METHOD) == SMART_PAGING_WORD_LIMIT_METHOD) {
          $value = t(' (!value words)', array('!value' => variable_get('smart_paging_word_count', 512)));
          $default_method = $method_options[SMART_PAGING_WORD_LIMIT_METHOD] . $value;
        }
        else {
          $default_method = $method_options[SMART_PAGING_NO_METHOD];
        }
        $default_method .= t(', Title suffix="') . variable_get('smart_paging_title_suffix', t(': Page ')) . '"';
        drupal_add_js(array('smart_paging' => array('default_method' => $default_method)), 'setting');
        $form['smart_paging_settings'] += array(              
          '#attached' 	 => array(
            'js' => array(drupal_get_path('module', 'smart_paging') . '/js/smart_paging-admin.js'),
          ),
          '#attributes'  => array('class' => array('smart-paging-settings')),
          '#group'       => 'additional_settings',
        );
      }
      $form['smart_paging_settings']['smart_paging_use_default'] = array(
        '#type' => 'checkbox', 
        '#title' => t('Use default values'),
        '#default_value' => isset($smart_paging_config['use_default']) ? $smart_paging_config['use_default'] : TRUE,
      );
      $form['smart_paging_settings']['smart_paging_method'] = array(
        '#type'          => 'select', 
        '#title'         => t('Page break method'),
        '#default_value' => isset($smart_paging_config['method']) ? $smart_paging_config['method'] : variable_get('smart_paging_method', SMART_PAGING_PLACEHOLDER_METHOD),
        '#options'       => $method_options,
        '#states'        => array(
          'disabled' => array(
            ':input[name="smart_paging_use_default"]' => array('checked' => TRUE),
          ),
        ),
      );
      $form['smart_paging_settings']['smart_paging_pagebreak'] = array(
        '#type'          => 'textfield',
        '#title'         => t('Page break placeholder'),
        '#default_value' => isset($smart_paging_config['pagebreak']) ? $smart_paging_config['pagebreak'] : variable_get('smart_paging_pagebreak', '<!--pagebreak-->'),
        '#description'   => t('HTML comment or valid HTML tag with unique identifier, eg. &lt;hr class="pagebreak" /&gt;.'),
        '#size'          => 50,
        '#states'        => array(
          'visible' => array(
            ':input[name="smart_paging_method"]' => array(
              'value'   => (string) SMART_PAGING_PLACEHOLDER_METHOD, 
              'enabled' => TRUE,
            ),
          ),
        ),
      );
      $form['smart_paging_settings']['smart_paging_character_count'] = array(
        '#type'          => 'textfield',
        '#title'         => t('Character limit'),
        '#description'   => t('Number of characters that will be shown for each page when "Automatic page break by character limit" is selected.'),
        '#default_value' => isset($smart_paging_config['character_count']) ? $smart_paging_config['character_count'] : variable_get('smart_paging_character_count', 3072),
        '#size'          => 50,
        '#states'        => array(
          'visible' => array(
            ':input[name="smart_paging_method"]' => array(
              'value'   => (string) SMART_PAGING_CHARACTER_LIMIT_METHOD,
              'enabled' => TRUE,
            ),
          ),
        ),
      );
      $form['smart_paging_settings']['smart_paging_word_count'] = array(
        '#type'          => 'textfield',
        '#title'         => t('Word limit'),
        '#description'   => t('Number of words that will be shown for each page when "Automatic page break by word limit" is selected.'),
        '#default_value' => isset($smart_paging_config['word_count']) ? $smart_paging_config['word_count'] : variable_get('smart_paging_word_count', 512),
        '#size'          => 50,
        '#states'        => array(
          'visible' => array(
            ':input[name="smart_paging_method"]' => array(
              'value'   => (string) SMART_PAGING_WORD_LIMIT_METHOD,
              'enabled' => TRUE,
            ),
          ),
        ),
      );
      $form['smart_paging_settings']['smart_paging_title_suffix'] = array(
        '#type'          => 'textfield',
        '#title'         => t('Content title suffix'),
        '#description'   => t("Text that will appear next to content's sub pages title (default is %suffix), eg. Title%suffix 2, Title%suffix 3 and so on...", array('%suffix' => t(': Page '))),
        '#default_value' => isset($smart_paging_config['title_suffix']) ? $smart_paging_config['title_suffix'] : variable_get('smart_paging_title_suffix', t(': Page ')),
        '#size'          => 50,
        '#states'        => array(
          'invisible' => array(
            ':input[name="smart_paging_method"]' => array(
              'value'   => (string) SMART_PAGING_NO_METHOD,
            ),
          ),
          'disabled' => array(
            ':input[name="smart_paging_use_default"]' => array('checked' => TRUE),
          ),
        ),
      );
      $form['#validate'][] = '_smart_paging_settings_validate';
      $form['#submit'][]   = '_smart_paging_settings_submit';
    }
  }
}

/**
 * Smart Paging settings validation handler.
 */
function _smart_paging_settings_validate($form, &$form_state) {
  if (strpos($form_state['values']['smart_paging_pagebreak'], '<') === FALSE || strpos($form_state['values']['smart_paging_pagebreak'], '>') != (drupal_strlen($form_state['values']['smart_paging_pagebreak']) - 1)) {
    form_set_error('smart_paging_pagebreak', t('Page break placeholder is not a valid HTML tag or comment.'));
  }
  if (!is_numeric($form_state['values']['smart_paging_character_count'])) {
    form_set_error('smart_paging_character_count', t('Character limit should be numeric value.'));
  }
  if (!is_numeric($form_state['values']['smart_paging_word_count'])) {
    form_set_error('smart_paging_word_count', t('Word limit should be numeric value.'));
  }
}

/**
 * Smart Paging settings submit handler.
 */
function _smart_paging_settings_submit($form, &$form_state) {
  if (isset($form_state['values']['smart_paging_use_default']) && isset($form_state['storage']['smart_paging_entity_id'])) {
    $smart_paging_use_default = $form_state['values']['smart_paging_use_default'];
    $entity_type = $form_state['storage']['smart_paging_entity_type'];
    $entity_id   = $form_state['storage']['smart_paging_entity_id'];
    $config = array(
      'use_default'     => $smart_paging_use_default,
      'method'          => !$smart_paging_use_default ? $form_state['values']['smart_paging_method'] : variable_get('smart_paging_method', SMART_PAGING_PLACEHOLDER_METHOD),
      'pagebreak'       => !$smart_paging_use_default ? $form_state['values']['smart_paging_pagebreak'] : variable_get('smart_paging_pagebreak', '<!--pagebreak-->'),
      'character_count' => !$smart_paging_use_default ? $form_state['values']['smart_paging_character_count'] : variable_get('smart_paging_character_count', 3072),
      'word_count'      => !$smart_paging_use_default ? $form_state['values']['smart_paging_word_count'] : variable_get('smart_paging_word_count', 512),
      'title_suffix'    => !$smart_paging_use_default ? $form_state['values']['smart_paging_title_suffix'] : variable_get('smart_paging_title_suffix', t(': Page ')),
    );
    try {
      db_insert('smart_paging')
        ->fields(array(
          'entity_id',
          'entity_type',
          'configuration',
        ))
        ->values(array(
          'entity_id'     => $entity_id,
          'entity_type'   => $entity_type,
          'configuration' => serialize($config),
        ))
        ->execute();
    }
    catch(Exception $error) {
      db_update('smart_paging')
        ->fields(array(
          'configuration' => serialize($config),
        ))
        ->condition('entity_id', $entity_id)
        ->condition('entity_type', $entity_type)
        ->execute();
    }
  }
}

/**
 * Implements hook_node_delete().
 */
function smart_paging_node_delete($node) {
  db_delete('smart_paging')
    ->condition('entity_id', $node->nid)
    ->condition('entity_type', 'node')
    ->execute();
}

/**
 * Implements hook_user_delete().
 */
function smart_paging_user_delete($account) {
  db_delete('smart_paging')
    ->condition('entity_id', $account->uid)
    ->condition('entity_type', 'user')
    ->execute();
}

/**
 * Implements hook_taxonomy_term_delete().
 */
function smart_paging_taxonomy_term_delete($term) {
  db_delete('smart_paging')
    ->condition('entity_id', $term->tid)
    ->condition('entity_type', 'taxonomy_term')
    ->execute();
}

/**
 * Implements hook_entity_insert().
 */
function smart_paging_entity_insert($entity, $entity_type) {
  if (isset($entity->smart_paging_use_default)) {
    foreach (entity_get_info() as $type => $info) {
      $entity_types[$type] = $info['entity keys']['id'];
    }
    $entity_id = $entity->{$entity_types[$entity_type]};
    $config = array(
      'use_default'     => $entity->smart_paging_use_default,
      'method'          => !$entity->smart_paging_use_default ? $entity->smart_paging_method : variable_get('smart_paging_method', SMART_PAGING_PLACEHOLDER_METHOD),
      'pagebreak'       => !$entity->smart_paging_use_default ? $entity->smart_paging_pagebreak : variable_get('smart_paging_pagebreak', '<!--pagebreak-->'),
      'character_count' => !$entity->smart_paging_use_default ? $entity->smart_paging_character_count : variable_get('smart_paging_character_count', 3072),
      'word_count'      => !$entity->smart_paging_use_default ? $entity->smart_paging_word_count : variable_get('smart_paging_word_count', 512),
      'title_suffix'    => !$entity->smart_paging_use_default ? $entity->smart_paging_title_suffix : variable_get('smart_paging_title_suffix', t(': Page ')),
    );
    try {
      db_insert('smart_paging')
        ->fields(array(
          'entity_id',
          'entity_type',
          'configuration',
        ))
        ->values(array(
          'entity_id'     => $entity_id,
          'entity_type'   => $entity_type,
          'configuration' => serialize($config),
        ))
        ->execute();
    }
    catch(Exception $error) {
      db_update('smart_paging')
        ->fields(array(
          'configuration' => serialize($config),
        ))
        ->condition('entity_id', $entity_id)
        ->condition('entity_type', $entity_type)
        ->execute();
    }
  }
}

/**
 * Implements hook_url_inbound_alter().
 */
function smart_paging_url_inbound_alter(&$path, &$original_path, $path_language) {
  $arg_count = count(arg()) - 1;
  $page      = arg($arg_count);
  $sub_page  = arg($arg_count - 1);
  // Check if path has pattern of http://example.com/<path alias>/<pager prefix>/<sub_page>/<page>
  if ($arg_count > 2 && is_numeric($sub_page) && is_numeric($page)) {
    if (arg($arg_count - 2) == variable_get('smart_paging_path_prefix', 'page')) {
      // Set the 'page' value of GET method
      $_GET['page'] = "$sub_page,$page";
      // Extract alias from arg()
      $alias = arg();
      unset($alias[$arg_count - 2], $alias[$arg_count - 1], $alias[$arg_count]);
      // Get the Drupal system URL for a path alias
      $drupal_path = drupal_lookup_path('source', implode('/', $alias) , $path_language);
      if (!empty($drupal_path)) {
        // Alter inbound URL request
        $path = $drupal_path;
      }
    }
  }
}

/**
 * Implements hook_url_outbound_alter().
 *
 * Change pagination query type URL to a clean URL
 */
function smart_paging_url_outbound_alter(&$path, &$options, $original_path) {
  if (isset($options['query']['page'])) {
    if (!empty($path) && !$options['alias']) {
      $language = isset($options['language']) && isset($options['language']->language) ? $options['language']->language : '';
      $alias = drupal_get_path_alias($original_path, $language);
      if ($alias != $original_path) {
        $path = $alias;
        $options['alias'] = TRUE;
      }
      else {
        $path_arg = arg();
        $path_arg = array_slice($path_arg, 0, array_search(variable_get('smart_paging_path_prefix', 'page'), $path_arg));
        $path = empty($path_arg) ? $original_path : implode('/', $path_arg);
      }
    }
    $page_query = explode(',', $options['query']['page']);
    $sub_page = $page_query[0];
    $page  = isset($page_query[1]) ? $page_query[1] : '0';
    $path .= '/' . variable_get('smart_paging_path_prefix', 'page') . "/$sub_page/$page";
    unset($options['query']['page']);
  }
}

/**
 * Implements hook_field_attach_view_alter().
 */
function smart_paging_field_attach_view_alter(&$build, $context) {
  // Teaser view and comment entity type (it has its own pagination) are not included
  if ($context['entity_type'] != 'comment' && $context['view_mode'] != 'teaser') {
    global $pager_page_array, $pager_total;
    $total_page   = 0;
    $output_index = 0;
    $current_page = 0;
    // Element index of our pager in multiple pagers on one page.
    $pager_element = 1;
    // Determine the user's current viewing page number
    if (isset($_GET['page'])) {
      $pager_page_array = explode(',', $_GET['page']);
      $current_page     = $pager_page_array[$pager_element];
      $output_index     = $current_page;
    }
    $fields = array();
    // Sort array fields according to weight
    foreach (element_children($build) as $field_name) {
      $fields[$build[$field_name]['#weight']][$field_name] = $build[$field_name];
    }
    ksort($fields);
    foreach ($fields as $field) {
      $field_name = key($field);
      $is_label_hidden = TRUE;
      foreach ($build[$field_name] as $delta => $field_content) {
        if (is_numeric($delta)) {
          $is_smart_paging_filter_found = strpos($field_content['#markup'], '<!--smart_paging_filter-->');
          $is_smart_paging_filter_done_found = strpos($field_content['#markup'], '<!--smart_paging_filter_done-->');
          if ($is_smart_paging_filter_found !== FALSE || $is_smart_paging_filter_done_found !== FALSE) {
            foreach (entity_get_info() as $type => $info) {
              $entity_types[$type] = $info['entity keys']['id'];
            }
            $entity_type = $context['entity_type'];
            $entity_id   = $context['entity']->{$entity_types[$entity_type]};
            $language    = $context['entity']->language;
            // Retrieve the stored Smart Paging settings
            $query = db_select('smart_paging', 'sp')
              ->condition('sp.entity_id', $entity_id)
              ->condition('sp.entity_type', $entity_type)
              ->fields('sp', array('configuration'))
              ->execute();
            $smart_paging_config = unserialize($query->fetchField(0));
            $smart_paging_use_default = isset($smart_paging_config['use_default']) ? $smart_paging_config['use_default'] : TRUE;
            $smart_paging_method = $smart_paging_use_default ? variable_get('smart_paging_method', SMART_PAGING_PLACEHOLDER_METHOD) : $smart_paging_config['method'];
            $placeholder = $smart_paging_use_default ? variable_get('smart_paging_pagebreak', '<!--pagebreak-->') : $smart_paging_config['pagebreak'];
            $markup_content = $field_content['#markup'];
            if ($current_page > 0) {
              $suffix = $smart_paging_use_default ? variable_get('smart_paging_title_suffix', t(': Page ')) : $smart_paging_config['title_suffix'];
              $title_suffix  = drupal_get_title() . t('@page', array('@page' => $suffix . ($current_page + 1)));
              drupal_set_title($title_suffix);
            }
          }
          // Check first if Smart Paging is allowed as input filter
          if ($is_smart_paging_filter_found !== FALSE) {
            // Remove the Smart Paging input filter marker
            $markup_content = str_replace('<!--smart_paging_filter-->', '', $markup_content);
            if ($smart_paging_method == SMART_PAGING_NO_METHOD) {
              // Do nothing, no paging is desired
              $cached_field = cache_get("field:$entity_type:$entity_id", 'cache_field');
              $cached_field->data[$field_name][$language][$delta]['safe_value'] = '<!--smart_paging_filter_done-->' . $markup_content;
              cache_set("field:$entity_type:$entity_id", $cached_field->data, 'cache_field');
              return;
            }
            if ($smart_paging_method != SMART_PAGING_PLACEHOLDER_METHOD) {
              // Check if breaking the page is based on number of characters
              if ($smart_paging_method == SMART_PAGING_CHARACTER_LIMIT_METHOD) {
                static $char_count = 0;
                $max_char = $smart_paging_use_default ? variable_get('smart_paging_character_count', 3072) : $smart_paging_config['character_count'];
              }
              // Check if breaking the page is based on number of words
              elseif ($smart_paging_method == SMART_PAGING_WORD_LIMIT_METHOD) {
                static $word_count = 0;
                $max_words = $smart_paging_use_default ? variable_get('smart_paging_word_count', 512) : $smart_paging_config['word_count'];
              }
              // Remove user defined Smart Paging placeholder, we don't need it here
              $markup_content = str_replace($placeholder, '', $markup_content);
              $split_tags = preg_split('/<(!--.*?--|[^>]+?)>/s', $markup_content, -1, PREG_SPLIT_DELIM_CAPTURE);
              $markup_content = '';
              foreach ($split_tags as $split_tags_key => $split_tags_value) {
                if ($split_tags_key & 1) {
                  $markup_content .= '<' . $split_tags_value . '>';
                }
                else {
                  if ($smart_paging_method == SMART_PAGING_CHARACTER_LIMIT_METHOD) {
                    $split_htmlcodes = preg_split('/(&[a-zA-Z]+;)/s', $split_tags_value, -1, PREG_SPLIT_DELIM_CAPTURE);
                    foreach ($split_htmlcodes as $split_htmlcodes_key => $split_htmlcodes_value) {
                      if ($split_htmlcodes_key & 1) {
                        // Count html charater as 1
                        $char_count++;
                        $markup_content .= $split_htmlcodes_value;
                      }
                      else {
                        $split_text = explode(' ', $split_htmlcodes_value);
                        $split_text_size = count($split_text);
                        foreach ($split_text as $text_value) {
                          $char_count += drupal_strlen($text_value);
                          $markup_content .= $text_value;
                          if ($split_text_size > 1) {
                            // Count the space
                            $char_count++;
                            $markup_content .= ' ';
                          }
                          if ($char_count >= $max_char) {
                            $markup_content .= $placeholder;
                            $char_count = 0;
                          }
                        }
                      }
                    }
                  }
                  else {
                    $split_text = explode(' ', $split_tags_value);
                    $split_text_size = count($split_text);
                    foreach ($split_text as $text_value) {
                      // Exclude whitespace
                      if (preg_match('/\S/s', $text_value)) {
                        ++$word_count;
                      }
                      $markup_content .= $text_value;
                      if ($split_text_size > 1) {
                        $markup_content .= ' ';
                      }
                      if ($word_count >= $max_words) {
                        $markup_content .= $placeholder;
                        $word_count = 0;
                      }
                    }
                  }
                }
              }
            }
            // Break HTML content properly and insert placeholder
            $markup_content = smart_page_break_insert_placeholder($markup_content);
            // Check if last page is an empty tag
            $pagebreak = array_filter(explode($placeholder, $markup_content));
            $pagebreak_end = count($pagebreak) - 1;
            $last_page = strip_tags($pagebreak[$pagebreak_end]);
            if (empty($last_page)) {
              // Remove the last page with only an empty tag content
              unset($pagebreak[$pagebreak_end]);
            }
            $markup_content = implode($placeholder, $pagebreak);
            // Save the processed page break content to cache
            $cached_field = cache_get("field:$entity_type:$entity_id", 'cache_field');
            $cached_field->data[$field_name][$language][$delta]['safe_value'] = '<!--smart_paging_filter_done-->' . $markup_content;
            cache_set("field:$entity_type:$entity_id", $cached_field->data, 'cache_field');
          }
          if ($is_smart_paging_filter_found !== FALSE || $is_smart_paging_filter_done_found !== FALSE) {
            // Remove the Smart Paging input filter done marker
            $markup_content = str_replace('<!--smart_paging_filter_done-->', '', $markup_content);
            if (empty($pagebreak)) {
              // Break the content based on user's included page break placeholders
              $pagebreak = array_filter(explode($placeholder, $markup_content));
            }
            $pagebreak_count = count($pagebreak);
            if ($pagebreak_count > 1) {
              if ($total_page) {
                // At this point, we are in next succeeding fields. This field
                // content will be shown at the last page of the previous field
                $output_index = $current_page - $total_page;
              }
              $output = '';
              if (isset($pagebreak[$output_index])) {
                $output = $pagebreak[$output_index];
              }
              // Record total number of pages
              $total_page += count($pagebreak);
              // Final field content output
              $build[$field_name][$delta]['#markup'] = $output;
              if (!empty($output)) {
                $is_label_hidden = FALSE;
              }
            }
            else {
              $is_label_hidden = FALSE;
            }
          }
        }
      }
      if ($is_label_hidden) {
        $build[$field_name]['#label_display'] = 'hidden';
      }
    }
    if (!empty($total_page)) {
      $pager_total[$pager_element] = $total_page;
      $variables['tags']     = array();
      $variables['element']  = $pager_element;
      $variables['quantity'] = 10;
      $build['smart_paging']['#markup'] = theme('pager', $variables);
      $build['smart_paging']['#weight'] = 10;
    }
  }
  // Comment entity
  else {
    foreach (element_children($build) as $field_name) {
      foreach ($build[$field_name] as $delta => $field_content) {
        if (is_numeric($delta)) {
          // Check first if there's a Smart Paging filter placeholder
          if (strpos($field_content['#markup'], '<!--smart_paging_filter-->') !== FALSE) {
            $markup_content = $field_content['#markup'];
            // Remove the Smart Paging input filter marker and placeholder for comment entity
            $markup_content = str_replace('<!--smart_paging_filter-->', '', $markup_content);            
            $markup_content = str_replace(variable_get('smart_paging_pagebreak', '<!--pagebreak-->'), '', $markup_content);
            $build[$field_name][$delta]['#markup'] = $markup_content;
          }
        }
      }
    }
  }
}

/**
 * Implements hook_permission().
 */
function smart_paging_permission() {
  return array(
    'administer smart_paging' => array(
      'title' => t('Administer Smart Paging'),
    ),
  );
}

/**
 * Implements hook_filter_info().
 */
function smart_paging_filter_info() {
  $filters['filter_html'] = array(
    'title'            => t('Smart Paging'),
    'process callback' => '_filter_smart_paging_process',
    'tips callback'    => '_filter_smart_paging_tips',
  );
  return $filters;
}

/**
 * Filter process callback
 *
 * Add a marker that indicates Smart Paging is included in allowed
 * list of content input filtering.
 */
function _filter_smart_paging_process($text, $filter, $format, $langcode, $cache, $cache_id) {
  return '<!--smart_paging_filter-->' . $text;
}

/**
 * Filter tips callback
 *
 * The returned string will be shown in the content add/edit form.
 */
function _filter_smart_paging_tips($filter, $format, $long = FALSE) {
  if (!$long) {
    return t("Allows breaking the content into pages by manually inserting %pagebreak placeholder or automatic page break by character or word limit, it depends on your settings below. Note: this will work only for CCK fields except for %comment entity CCK fields.", array('%pagebreak' => variable_get('smart_paging_pagebreak', '<!--pagebreak-->'), '%comment' => t('comment')));
  }
}

/**
* Implements hook_help().
*/
function smart_paging_help($path, $arg) {
  switch ($path) {
    case 'admin/help#smart_paging':
      return '<p>' . 
      t('Provides splitting up long Drupal content into sub pages by number of characters/words or by 
      a placeholder HTML tag. It splits complex HTML markup content more accurately:') . 
      '</p><div class="messages"><pre>
&lt;div class="text-important"&gt;
  &lt;p class="info"&gt;
  Long content paragraph... 
&lt;!--pagebreak--&gt;
  Continuation of long content paragraph.
  &lt;/p&gt;
  &lt;ul class="text-note"&gt;
    &lt;li&gt;List #1&lt;/li&gt;
    &lt;li&gt;Long list #2...
 &lt;!--pagebreak--&gt;
    Continuation of long list #2&lt;/li&gt;
    &lt;li&gt;List #3&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;</pre></div>
      <p>into this...</p>
      <p>' . t(' - Page 1 - ') . '<br />
      http://www.example.com/node/1/page/0/0</p><div class="messages"><pre>
&lt;div class="text-important"&gt;
  &lt;p class="info"&gt;
  Long content paragraph... 
  &lt;/p&gt;
&lt;/div&gt;</pre></div>
      <p>' . t(' - Page 2 - ') . '<br />
      http://www.example.com/node/1/page/0/1</p><div class="messages"><pre>
&lt;div class="text-important"&gt;
  &lt;p class="info"&gt;
  Continuation of long content paragraph.
  &lt;/p&gt;
  &lt;ul class="text-note"&gt;
    &lt;li&gt;List #1&lt;/li&gt;
    &lt;li&gt;Long list #2...&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;</pre></div> 
      <p>' . t(' - Page 3 - ') . '<br />
      http://www.example.com/node/1/page/0/2</p><div class="messages"><pre>
&lt;div class="text-important"&gt;
  &lt;ul class="text-note"&gt;
    &lt;li&gt;Continuation of long list #2&lt;/li&gt;
    &lt;li&gt;List #3&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;</pre></div><p>' . 
      t('Smart Paging feature can be applied only to CCK fields (with text format) of node, user and 
      taxonomy term entities. URL for sub pages made more SEO friendly and works even for aliased 
      URL path. The user has more control over Smart Paging configuration, each content has its 
      own Smart Paging settings.') . '</p>';
      break;
  }
}

/******************************************************************************
 * Helper functions                                                           *
 ******************************************************************************/

/**
 * Break HTML content and insert placeholder
 *
 * Helper function to properly break HTML content and insert placeholder.
 *
 * @param $text
 *   HTML text content.
 * @param $placeholder
 *   Placeholder string to be inserted between broken page.
 * @return
 *   HTML output of properly break HTML content and insert placeholder.
 */
function smart_page_break_insert_placeholder($text, $placeholder = '<!--pagebreak-->') {
  // Perform HTML correction
  $text = _filter_htmlcorrector($text);
  $break_map = array();
  $text   = str_replace($placeholder, '<smart_paging_placeholder>', $text) . '<smart_paging_placeholder>';
  $struct = smart_page_pair_tags($text);
  $split  = $struct['split'];
  $tag_pairs_map    = $struct['tag_pairs_map'];
  $break_positions  = array_keys($tag_pairs_map['smart_paging_placeholder']);
  unset($tag_pairs_map['smart_paging_placeholder']);
  foreach ($break_positions as $break_index => $break_end) {
    if ($break_index) {
      $break_start = $break_positions[$break_index - 1];
      $break_map[$break_end] = array_slice($split, $break_start, ($break_end - $break_start), TRUE);
      // Remove the placeholder from the structure 
      unset($break_map[$break_end][$break_start]);
    }
    else {
      $break_start = $break_index;
      $break_map[$break_end] = array_slice($split, $break_start, ($break_end - $break_start), TRUE);
    }
    foreach ($tag_pairs_map as $tag_name => $map) {
      foreach ($map as $open_tag_pos => $close_tag_pos) {
        if (($open_tag_pos < $break_end && $close_tag_pos > $break_end) || ($open_tag_pos < $break_start && $close_tag_pos > $break_start) || ($open_tag_pos > $break_start && $close_tag_pos < $break_end && $close_tag_pos !== NULL) || ($open_tag_pos > $break_start && $open_tag_pos < $break_end && $close_tag_pos === NULL)) {
          if (empty($close_tag_pos)) {
            $break_map[$break_end][$open_tag_pos] = '<' . $split[$open_tag_pos] . '>';
          }
          else {
            $break_map[$break_end][$open_tag_pos]  = '<' . $split[$open_tag_pos] . '>';
            $break_map[$break_end][$close_tag_pos] = '<' . $split[$close_tag_pos] . '>';
          }
        }
      }
    }
    ksort($break_map[$break_end]);
    if (isset($output)) {
      $output .= $placeholder . implode('', $break_map[$break_end]);
    }
    else {
      $output = implode('', $break_map[$break_end]);
    }
  }
  return $output;
}

/**
 * Create page content HTML paired tags structure
 *
 * Helper function to create a structured HTML paired tags mappings.
 *
 * @param $text
 *   HTML text content.
 * @return
 *   An associative array containing:
 *   - split: array of split HTML tag(s) from text.
 *   - tag_pairs_map: Array of structured HTML paired tags mapping:
 *   $array[<tag name>][<open tag position>] = <close tag position>
 */
function smart_page_pair_tags($text) {
  $tag_pairs_map = array();
  // Properly entify angles.
  $text = preg_replace('@<(?=[^a-zA-Z!/]|$)@', '&lt;', $text);
  // Split tags from text.
  $split = preg_split('/<(!--.*?--|[^>]+?)>/s', $text, -1, PREG_SPLIT_DELIM_CAPTURE);
  // Note: PHP ensures the array consists of alternating delimiters and literals
  // and begins and ends with a literal (inserting null as required).
  foreach ($split as $position => $value) {
    // Tags are in array's odd number index
    if ($position & 1) {
      list($tagname) = explode(' ', $value);
      if ($tagname[0] == '/') {
        $tagname = strtolower(substr($tagname, 1));
        end($tag_pairs_map[$tagname]);
        // Its open tag pair is the last item in the array with empty value
        while ($tag_value = current($tag_pairs_map[$tagname])) {
          prev($tag_pairs_map[$tagname]);
        }
        $pair_pos = key($tag_pairs_map[$tagname]);
        // Save position of closing tag to its pair open tag
        $tag_pairs_map[$tagname][$pair_pos] = $position;
      }
      else {
        $tagname = strtolower($tagname);
        // Save position of open tag. For now, closing tag is still unidentified
        $tag_pairs_map[$tagname][$position] = NULL;
      }
    }
  }
  return array(
    'split' => $split,
    'tag_pairs_map' => $tag_pairs_map,
  );
}

/**
 * Helper function for grabbing Smart Paging method list.
 */
function _smart_paging_method_list() {
	$methods = &drupal_static(__FUNCTION__);
  
	if (!isset($methods)) {
    $methods = array(
      SMART_PAGING_NO_METHOD              => t('Bypass Smart Paging input filter'),
      SMART_PAGING_PLACEHOLDER_METHOD     => t('Manual placement of page break placeholder'), 
      SMART_PAGING_CHARACTER_LIMIT_METHOD => t('Automatic page break by character limit'), 
      SMART_PAGING_WORD_LIMIT_METHOD      => t('Automatic page break by word limit'),
    );
	}
	return $methods;
}